           # Nio的与io的区别 #
一、 Nio的简介
    Java NIO(New IO , Non-Blocking IO)是从java 1.4版本开始引入的一套新的io Api，nio与原本的io 有同样的作用与目的,nio支持面向缓冲区 基于通道的io操作，NIO将以更加高效的方式进行文件读写操作

二、 Nio与传统Io的区别

    Nio:面向缓冲  同步非阻塞   选择器(多路复用)
    Io:面向流     同步阻塞   无选择器
    
    nio三大核心组件: 通道(Channel)、缓冲区(buffer)、选择器(Selector)

    NIO是非阻塞的,IO是阻塞的,所以效率上NIO要高一点
    IO完成一次读写过程要产生大量的流对象 - 是单向的；NIO完成双向传输，因此可以减少流的创建数量
    一对一的连接：客户端的每一个请求在服务器端都必须有一个线程与之对应；NIO所使用的一对多的机制：可以利用一个或者少量线程去处理大量的请求
    连接一旦建立，即使没有后续操作，这个客户端依然会占用服务器端的线程；NIO会建立选择机制，会根据客户端的请求来确定是否分配线程
    1、面向缓冲

    传统IO是面向流的，NIO是面向缓冲的。传统IO是每次从流中读一个或多个字节，直到读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。NIO是将数据读取到一个她稍后处理的缓冲区，需要时可在缓冲区中前后移动，增加了处理过程中的灵活性。

    2、同步非阻塞

    传统IO的流是阻塞的，当一个线程调用read() 或 write()时，该线程被阻塞，直到数据完成读取或写入完成，此期间该线程不能再干任何事情了。NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。

    3、多路复用

    多路复用是指使用单线程也可以通过轮询监控的方式实现多线程类似的效果。简单的说就是，通过选择机制，使用一个单独的线程很容易来管理多个通道。

三、NIO常用API

    (1)、通道（Channel）

    Channel是传统IO中的Stream(流)的升级版，Stream是单向的、读写分离，Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。
    用于进行数据的传输
    面向缓冲区进行操作
    可以进行双向传输
    针对文件的通道：FileChannel
    针对网络的通道：
    UDP - DatagramChannel
    TCP - SocketChannel ServerSocketChannel
    通道默认是阻塞的，手动设置为非阻塞


    (2)、缓冲区（Buffer）

    Buffer可以理解为一块内存区域，可以写入数据，并且在之后读取它。这块内存被包装成NIO buffer对象，它提供了一些方法来更简单地操作内存。
    用于存储数据
    底层是基于数组来进行存储
    只能存储基本类型
    针对八种基本类型分别提供了对应的缓冲区类，但是没有boolean类型：ByteBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer,CharBuffer
    重要的位置:mark <= position <= limit <= capacity
    a. capacity:容量位.指定缓冲区的容量/大小
    b. limit:限制位.用于限定操作位所能达到的最大下标.缓冲区刚刚创建的时候,限值位和容量位是一样的
    c. position:操作位.类似于数组中的下标,用于指向要读写的位置.缓冲区刚刚创建的时候,操作位是指向第0位的
    d. mark:标记位.标记位默认是不启用的
    重要的操作:
    a. flip:翻转缓冲区
    b. reset:重置缓冲区
    c. rewind:重绕缓冲区
    d. clear:清空缓冲区
     

    (3)、选择器（Selector）


    选择器（Selector）可以实现一个单独的线程来监控多个注册在她上面的通道（Channel），通过一定的选择机制，实现多路复用的效果。
    针对有用的请求进行选择：accept、read、write
    针对通道进行选择，要求通道必须是非阻塞的
    非阻塞的实现就是基于selector，所谓的多路复用，即是一个线程管理多个channel

    Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式

    select()
    调用此方法，会将上次 select 之后的准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。

    selectNow()
    功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。

    select(long timeout)
    看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会

    wakeup()
    这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。


